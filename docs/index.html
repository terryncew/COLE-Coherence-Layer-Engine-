<script>
(async function(){
  const $ = id => document.getElementById(id);
  const grid = $('grid');
  const pill=$('statusPill'), dot=$('statusDot'), txt=$('statusText');
  const glyph=$('glyph'), leg=$('legend');
  const barK=$('barK'), barD=$('barD'), barKTick=$('barKTick'), barDTick=$('barDTick');
  const barKVal=$('barKVal'), barDVal=$('barDVal');
  const msgBox=$('msgBox'), warnBox=$('warnBox'), redBox=$('redBox');

  function tile(label, value, hint, cls){
    const c=document.createElement('div'); c.className='card';
    const row=document.createElement('div'); row.className='kpi';
    const lamp=document.createElement('div'); lamp.className='lamp '+(cls||'mutelamp');
    const b=document.createElement('div'); b.className='big'; b.textContent=value;
    const cap=document.createElement('div'); cap.innerHTML =
      `<div class="muted">${label}</div><div class="muted" style="font-size:11px">${hint||''}</div>`;
    row.appendChild(lamp); row.appendChild(b); c.appendChild(row); c.appendChild(cap); return c;
  }

  const cfgDefault={tau_k:.75,tau_hol:.35,ucr_min:.40,es_min:.25};
  async function jget(path){
    try{ const u=new URL(path,location.href); u.searchParams.set('v',Date.now()); const r=await fetch(u,{cache:'no-store'}); return r.ok? r.json(): null; }
    catch{ return null; }
  }

  // load receipt, guard thresholds, and (optional) policy for bands/tau_review
  const [rec, cfg, policy] = await Promise.all([
    jget('./receipt.latest.json'),
    jget('./guard.14l.json'),
    jget('./policy.json')
  ]);
  const guard = cfg || cfgDefault;
  const bands = (policy && policy.bands) || {green:[0,0.20], amber_monitor:[0.20,0.35], amber_investigate:[0.35,0.80]};
  const tau_review = (policy && policy.tau_review)!=null ? policy.tau_review : bands.amber_investigate[0];

  if(!rec){
    grid.appendChild(tile('No receipt found','—','Add docs/receipt.latest.json','warn'));
    $('rules').textContent='No receipt found. Run your workflow to generate docs/receipt.latest.json.';
    return;
  }

  const of=rec.openline_frame||{}, t=of.telem||{}, d=of.digest||{}, latest=(rec.temporal&&rec.temporal.latest)||{};
  const hz=rec.hazard||{};
  const num = v => (Number.isFinite(+v) ? +v : 0);
  const k   = num(t.kappa_eff ?? latest.kappa);
  const dhol= num(t.delta_hol ?? latest.delta_hol);
  const ucr = num(d.ucr);
  const es  = num(t.evidence_strength);
  const cyc = num(d.cycle_plus);
  const X   = num(d.x_frontier);
  const pRev= num(hz.p_review);
  const kWin= num(hz.k_window);

  // status (prefer explicit badge/status; fall back to policy)
  function policyStatus(){
    if (cyc>0) return 'red';
    const red = ( (dhol>=guard.tau_hol && (t.del_suspect===true)) ||
                  (k>=guard.tau_k && ucr>=guard.ucr_min && es<guard.es_min) );
    if (red) return 'red';
    const amber = (k>=guard.tau_k) || (dhol>=guard.tau_hol) || (ucr>=guard.ucr_min);
    return amber ? 'amber' : 'green';
  }
  let status = String(rec.badge||rec.status||'').toLowerCase();
  if(!status) status = policyStatus();
  // warm-up always shows WHITE
  if (kWin && kWin < 3) status = 'white';

  const color = s => s==='red' ? '#dc2626' : (s==='amber' ? '#f59e0b' : (s==='green' ? '#16a34a' : '#9aa0aa'));

  // KPI tiles
  const cK = v => (v>=guard.tau_k?'warn':'ok');
  const cD = v => (v>=guard.tau_hol?'warn':'ok');
  const cU = v => (v>=guard.ucr_min?'warn':'ok');
  const cE = v => (v< guard.es_min?'warn':'ok');
  grid.appendChild(tile('κ (stress)', k.toFixed(3), 'Density vs structure', cK(k)));
  grid.appendChild(tile('Δhol (drift)', dhol.toFixed(3), 'Path mismatch (EWMA JSD)', cD(dhol)));
  grid.appendChild(tile('UCR', (ucr*100).toFixed(0)+'%', 'Unsupported-claim ratio', cU(ucr)));
  grid.appendChild(tile('ES', (es*100).toFixed(0)+'%', 'Evidence strength', cE(es)));
  grid.appendChild(tile('Cycles', String(cyc), 'cycle⁺ > 0 → RED', (cyc>0?'bad':'ok')));
  grid.appendChild(tile('X (contradictions)', String(X), 'Unresolved contradictions', (X>0?'warn':'ok')));

  // Status pill + updated time
  txt.textContent=status.toUpperCase();
  dot.className='dot '+(status==='red'?'badd':(status==='amber'?'warnd':(status==='green'?'okd':'mutelamp')));
  pill.hidden=false;
  $('updated').textContent = new Date((of.t_logical? of.t_logical*1000 : Date.now())).toLocaleString();

  // Friendly messages + Why/Try next
  let why='', fix='';
  if (status==='white'){
    why = `Warming up — not enough history yet (window ${kWin || 0}/10).`;
    fix = 'Run a few more receipts to calibrate the baseline.';
    msgBox.hidden=true; warnBox.hidden=true; redBox.hidden=true;
  } else if (status==='green'){
    why = 'All guardrails within thresholds; hazard below review cutoff.';
    fix = 'No action needed.';
    msgBox.hidden=false; msgBox.textContent = 'All guardrails within thresholds. Looks good — no action needed.';
    warnBox.hidden=true; redBox.hidden=true;
  } else if (status==='amber'){
    // classify amber band for a better hint
    const band = (pRev>=bands.amber_investigate[0]) ? 'investigate' : 'monitor';
    if (cyc>0){ why='Circular reasoning detected (cycle⁺>0)'; fix='Break the loop; add external evidence or restructure claims.'; }
    else if (dhol>=guard.tau_hol && t.del_suspect){ why='Path drift with potential silent deletion'; fix='Add a resolution/handling sentence for removed contradictions.'; }
    else if (k>=guard.tau_k && ucr>=guard.ucr_min && es<guard.es_min){ why='High stress + unsupported claims + weak evidence'; fix='Add citations or “according to…” near claims.'; }
    else if (k>=guard.tau_k){ why='Elevated stress (κ high)'; fix='Shorten or add structure/support so S* rises.'; }
    else if (dhol>=guard.tau_hol){ why='Path drift (Δhol high)'; fix='Stabilize reasoning across turns; avoid rewriting without resolution.'; }
    else if (ucr>=guard.ucr_min){ why='Many claims lack nearby support'; fix='Place an evidence sentence or citation within ±1 sentence.'; }
    warnBox.textContent = (band==='monitor')
      ? 'Heads up (monitor): something is edging up. See “Why” / “Try next”.'
      : 'Investigate: hazard is above review threshold. See “Why” / “Try next”.';
    warnBox.hidden=false; msgBox.hidden=true; redBox.hidden=true;
  } else if (status==='red'){
    redBox.textContent = 'Blocked: guardrails tripped. Fix the issue and re-run.';
    redBox.hidden=false; warnBox.hidden=true; msgBox.hidden=true;
    if (cyc>0){ why='Circular reasoning detected (cycle⁺>0)'; fix='Break the loop; add external evidence or restructure claims.'; }
    else if (dhol>=guard.tau_hol && t.del_suspect){ why='Path drift with potential silent deletion'; fix='Add a resolution/handling sentence for removed contradictions.'; }
    else if (k>=guard.tau_k && ucr>=guard.ucr_min && es<guard.es_min){ why='High stress + unsupported claims + weak evidence'; fix='Add citations or “according to…” near claims.'; }
  }
  $('why').textContent = why || '—';
  $('fix').textContent = fix || '—';

  // Bars (0..1 scale; tick shows threshold)
  function setBar(bar, tick, value, thresh){
    const fill = Math.max(0, Math.min(1, value));
    bar.style.color = color(status);
    bar.querySelector('.fill').style.width = (fill*100).toFixed(1)+'%';
    tick.style.left = (Math.max(0, Math.min(1, thresh))*100).toFixed(1)+'%';
  }
  setBar(barK, barKTick, k,   guard.tau_k||.75);
  setBar(barD, barDTick, dhol,guard.tau_hol||.35);
  barKVal.textContent = k.toFixed(3);
  barDVal.textContent = dhol.toFixed(3);

  // Glyph (same as before)
  const axes = [
    {label:'κ',     val: Math.max(0, Math.min(1, (guard.tau_k? (k/(guard.tau_k||1)) : 0)))},
    {label:'Δhol',  val: Math.max(0, Math.min(1, (guard.tau_hol? (dhol/(guard.tau_hol||1)) : 0)))},
    {label:'UCR',   val: Math.max(0, Math.min(1, (guard.ucr_min? (ucr/(guard.ucr_min||1)) : 0)))},
    {label:'low ES',val: Math.max(0, Math.min(1, (guard.es_min? ((guard.es_min - es)/(guard.es_min||1)) : 0)))},
    {label:'cycles',val: cyc>0 ? 1 : 0},
    {label:'X',     val: Math.max(0, Math.min(1, X/3))}
  ];
  const cx=60, cy=60, R=48, N=axes.length;
  for(let r=1;r<=3;r++){
    const circ=document.createElementNS('http://www.w3.org/2000/svg','circle');
    circ.setAttribute('cx',cx); circ.setAttribute('cy',cy); circ.setAttribute('r',(R/3)*r);
    circ.setAttribute('fill','none'); circ.setAttribute('stroke','#e6eaf3'); circ.setAttribute('stroke-width','0.9');
    glyph.appendChild(circ);
  }
  axes.forEach((ax,i)=>{
    const a=-Math.PI/2 + i*(2*Math.PI/N);
    const x=cx + R*Math.cos(a), y=cy + R*Math.sin(a);
    const line=document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',cx); line.setAttribute('y1',cy); line.setAttribute('x2',x); line.setAttribute('y2',y);
    line.setAttribute('stroke','#e6eaf3'); line.setAttribute('stroke-width','0.9'); glyph.appendChild(line);
    const lbl=document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.setAttribute('x',cx+(R+10)*Math.cos(a)); lbl.setAttribute('y',cy+(R+10)*Math.sin(a));
    lbl.setAttribute('font-size','9'); lbl.setAttribute('fill','#6a6f7a');
    lbl.setAttribute('text-anchor', Math.cos(a)>0.35?'start':(Math.cos(a)<-0.35?'end':'middle'));
    lbl.setAttribute('dominant-baseline','middle'); lbl.textContent=ax.label; glyph.appendChild(lbl);
  });
  function pt(i,v){ const a=-Math.PI/2 + i*(2*Math.PI/N); const r=6+(R-6)*v; return [cx+r*Math.cos(a), cy+r*Math.sin(a)]; }
  const pts=axes.map((ax,i)=>pt(i,ax.val));
  const path='M'+pts.map(p=>p[0].toFixed(2)+','+p[1].toFixed(2)).join('L')+'Z';
  const poly=document.createElementNS('http://www.w3.org/2000/svg','path');
  poly.setAttribute('d', path);
  poly.setAttribute('fill', status==='red'?'#fee2e2':(status==='amber'?'#fff3cd':(status==='green'?'#ecfdf5':'#f3f4f6')));
  poly.setAttribute('stroke', color(status)); poly.setAttribute('stroke-width','1.6'); glyph.appendChild(poly);
  const hub=document.createElementNS('http://www.w3.org/2000/svg','circle');
  hub.setAttribute('cx',cx); hub.setAttribute('cy',cy); hub.setAttribute('r',2.1); hub.setAttribute('fill',color(status)); glyph.appendChild(hub);

  const chips=[`κ ${k.toFixed(3)}`, `Δhol ${dhol.toFixed(3)}`, `UCR ${(ucr*100).toFixed(0)}%`, `ES ${(es*100).toFixed(0)}%`, `cycles ${cyc}`, `X ${X}`];
  chips.forEach(s=>{ const span=document.createElement('span'); span.className='chip'; span.textContent=s; leg.appendChild(span); });

  // Rules footer — include WHITE explanation
  $('rules').textContent =
    `Rules: RED if cycle⁺>0; or (Δhol≥${guard.tau_hol} & del_suspect); or (κ≥${guard.tau_k} & UCR≥${guard.ucr_min} & ES<${guard.es_min}). ` +
    `AMBER if any one is high (monitor ${bands.amber_monitor[0]}–${bands.amber_monitor[1]}, investigate ${bands.amber_investigate[0]}–${bands.amber_investigate[1]} by p_review). ` +
    `GREEN if p_review<${bands.green[1]} for recent runs with no spikes. WHITE = warm-up (insufficient history, k_window<3).`;
})();
</script>
